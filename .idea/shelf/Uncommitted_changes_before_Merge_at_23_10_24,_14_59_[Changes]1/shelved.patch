Index: pkg/utils/validator.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package utils\n\nimport (\n\t\"regexp\"\n\n\t\"github.com/go-playground/validator/v10\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nfunc AppValidate() *validator.Validate {\n\tinstance := validator.New() // Инициализация валидатора\n\terr := instance.RegisterValidation(\"password\", validatePassword)\n\tif err != nil {\n\t\tlogrus.Errorf(\"Failed to register validator: %v\", err)\n\t}\n\treturn instance // Возврат инициализированного экземпляра\n}\n\n// Кастомный валидатор для пароля.\nfunc validatePassword(fl validator.FieldLevel) bool {\n\tpassword := fl.Field().String()\n\n\t// Минимальная длина 8 символов, максимальная 64 символа.\n\tif len(password) < 8 || len(password) > 64 {\n\t\treturn false\n\t}\n\n\t// Проверяем наличие хотя бы одной заглавной буквы\n\thasUppercase, hasLowercase, hasDigit, hasSpecialChar := regexp.MustCompile(`[A-Z]`).MatchString(password),\n\t\tregexp.MustCompile(`[a-z]`).MatchString(password),\n\t\tregexp.MustCompile(`[0-9]`).MatchString(password),\n\t\t///TODO: переделать тут валидацию\n\t\tregexp.MustCompile(`[!@#$%^&*begin:math:text$_\\+\\-=$end:math:text$_\\+\\-=$begin:math:display$$end:math:display$\\{\\};:'\"\\|\\\\,.<>/?]+`).MatchString(password) // Проверяем наличие хотя бы одной строчной буквы\n\t// Проверяем наличие хотя бы одной цифры.\n\t// Проверяем наличие хотя бы одного специального символа\n\n\t// Пароль должен содержать заглавную, строчную букву, цифру и спец символ.\n\treturn hasUppercase && hasLowercase && hasDigit && hasSpecialChar\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/utils/validator.go b/pkg/utils/validator.go
--- a/pkg/utils/validator.go	(revision 0effcea7acac9a98d85157cec6c816200f9564da)
+++ b/pkg/utils/validator.go	(date 1729683092907)
@@ -29,11 +29,10 @@
 	hasUppercase, hasLowercase, hasDigit, hasSpecialChar := regexp.MustCompile(`[A-Z]`).MatchString(password),
 		regexp.MustCompile(`[a-z]`).MatchString(password),
 		regexp.MustCompile(`[0-9]`).MatchString(password),
-		///TODO: переделать тут валидацию
+		// /TODO: переделать тут валидацию
 		regexp.MustCompile(`[!@#$%^&*begin:math:text$_\+\-=$end:math:text$_\+\-=$begin:math:display$$end:math:display$\{\};:'"\|\\,.<>/?]+`).MatchString(password) // Проверяем наличие хотя бы одной строчной буквы
 	// Проверяем наличие хотя бы одной цифры.
 	// Проверяем наличие хотя бы одного специального символа
-
 	// Пароль должен содержать заглавную, строчную букву, цифру и спец символ.
 	return hasUppercase && hasLowercase && hasDigit && hasSpecialChar
 }
Index: internal/domain/repository/jwt_repo.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/domain/repository/jwt_repo.go b/internal/domain/repository/jwt_repo.go
new file mode 100644
--- /dev/null	(date 1729672601096)
+++ b/internal/domain/repository/jwt_repo.go	(date 1729672601096)
@@ -0,0 +1,14 @@
+package repository
+
+import (
+	"marketplace/internal/domain/entities"
+	"marketplace/internal/domain/enums"
+
+	"github.com/labstack/echo/v4"
+)
+
+type JWTRepository interface {
+	SaveToken(userID uint64, token *entities.TokenDetails, tokenType enums.Token, ctx echo.Context) error
+	GetToken(userID uint64, tokenType enums.Token, ctx echo.Context) (*entities.TokenDetails, error)
+	DeleteToken(userID uint64, tokenType enums.Token, ctx echo.Context) error
+}
Index: internal/data/repository/jwt_repo_impl.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/data/repository/jwt_repo_impl.go b/internal/data/repository/jwt_repo_impl.go
new file mode 100644
--- /dev/null	(date 1729674034886)
+++ b/internal/data/repository/jwt_repo_impl.go	(date 1729674034886)
@@ -0,0 +1,99 @@
+package repository
+
+import (
+	"context"
+	"encoding/json"
+	"errors"
+	"fmt"
+	"marketplace/internal/domain/entities"
+	"marketplace/internal/domain/enums"
+	"marketplace/internal/domain/repository"
+
+	"github.com/go-redis/redis/v8"
+	"github.com/labstack/echo/v4"
+)
+
+// redisJWTRepository - реализация JWTRepository для Redis
+type redisJWTRepository struct {
+	redisClient *redis.Client
+	context     context.Context
+}
+
+// NewRedisJWTRepository - конструктор для создания нового экземпляра redisJWTRepository
+func NewRedisJWTRepository(redisClient *redis.Client) repository.JWTRepository {
+	return &redisJWTRepository{
+		redisClient: redisClient,
+		context:     context.Background(),
+	}
+}
+
+// SaveToken saves TokenDetails in Redis with a specified expiration time
+func (r *redisJWTRepository) SaveToken(
+	userID uint64,
+	token *entities.TokenDetails,
+	tokenType enums.Token,
+	ctx echo.Context,
+) error {
+	jsonToken, err := json.Marshal(token)
+	if err != nil {
+		return fmt.Errorf("failed to marshal token: %v", err)
+	}
+	if err = r.redisClient.SetEX(
+		r.context,
+		fmt.Sprintf(
+			"%s_%s:%d",
+			tokenType.String(),
+			ctx.Request().Header.Get("User-Agent"),
+			userID,
+		),
+		jsonToken,
+		tokenType.Duration(),
+	).Err(); err != nil {
+		return fmt.Errorf("failed to save token into Redis: %v", err)
+	}
+	return nil
+}
+
+// GetToken retrieves TokenDetails by userID
+func (r *redisJWTRepository) GetToken(
+	userID uint64,
+	tokenType enums.Token,
+	ctx echo.Context,
+) (*entities.TokenDetails, error) {
+	var token *entities.TokenDetails
+	tokenJson, err := r.redisClient.Get(
+		r.context,
+		fmt.Sprintf(
+			"%s_%s:%d",
+			tokenType.String(),
+			ctx.Request().Header.Get("User-Agent()"),
+			userID,
+		),
+	).Result()
+	if errors.Is(err, redis.Nil) {
+		return nil, fmt.Errorf("tokens not found")
+	} else if err != nil {
+		return nil, fmt.Errorf("error retrieving tokens: %v", err)
+	}
+
+	if err = json.Unmarshal([]byte(tokenJson), &token); err != nil {
+		return nil, fmt.Errorf("failed to unmarshal token: %v", err)
+	}
+	return token, nil
+}
+
+// DeleteToken removes tokens by userID
+func (r *redisJWTRepository) DeleteToken(userID uint64, tokenType enums.Token, ctx echo.Context) error {
+	err := r.redisClient.Del(r.context,
+		fmt.Sprintf(
+			"%s_%s:%d",
+			tokenType.String(),
+			ctx.Request().Header.Get("User-Agent"),
+			userID,
+		),
+	).Err()
+	if err != nil {
+		return fmt.Errorf("failed to delete tokens: %v", err)
+	}
+	return nil
+}
Index: internal/domain/enums/token.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/domain/enums/token.go b/internal/domain/enums/token.go
new file mode 100644
--- /dev/null	(date 1729563588421)
+++ b/internal/domain/enums/token.go	(date 1729563588421)
@@ -0,0 +1,21 @@
+package enums
+
+import (
+	"marketplace/pkg/constants"
+	"time"
+)
+
+type Token int
+
+const (
+	Access  Token = iota // 0
+	Refresh              // 1
+)
+
+func (t Token) String() string {
+	return [...]string{"access_token", "refresh_token"}[t]
+}
+
+func (t Token) Duration() time.Duration {
+	return [...]time.Duration{constants.AccessTokenLifetime, constants.RefreshTokenLifetime}[t]
+}
Index: internal/domain/entities/token_details.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/domain/entities/token_details.go b/internal/domain/entities/token_details.go
new file mode 100644
--- /dev/null	(date 1729563588420)
+++ b/internal/domain/entities/token_details.go	(date 1729563588420)
@@ -0,0 +1,8 @@
+package entities
+
+// TokenDetails хранит данные о токенах
+type TokenDetails struct {
+	Token     string `json:"token"`
+	UUID      string `json:"uuid"`
+	AtExpires int64  `json:"expires"`
+}
Index: pkg/constants/constants.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/constants/constants.go b/pkg/constants/constants.go
new file mode 100644
--- /dev/null	(date 1729563588422)
+++ b/pkg/constants/constants.go	(date 1729563588422)
@@ -0,0 +1,8 @@
+package constants
+
+import "time"
+
+const (
+	RefreshTokenLifetime = time.Hour * 24 * 365
+	AccessTokenLifetime  = 72 * time.Hour
+)
